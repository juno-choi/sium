-- Enable the UUID extension
create extension if not exists "uuid-ossp";

-- Reset (Drop existing tables if they exist)
drop table if exists public.flyers;
drop table if exists public.users;

-- 1. Users table (Public profile)
-- This table mirrors the Supabase Auth users table
create table public.users (
  id bigint generated by default as identity primary key,
  uuid uuid references auth.users not null unique,
  email text,
  full_name text,
  avatar_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS on users
alter table public.users enable row level security;

-- Policies for users
create policy "Public profiles are viewable by everyone."
  on public.users for select
  using ( true );

create policy "Users can insert their own profile."
  on public.users for insert
  with check ( auth.uid() = uuid );

create policy "Users can update own profile."
  on public.users for update
  using ( auth.uid() = uuid );

-- 2. Flyers table
create table public.flyers (
  id bigint generated by default as identity primary key,
  uuid uuid default uuid_generate_v4() not null unique,
  title text not null,
  description text,
  image_url text, -- Thumbnail
  
  -- Template System
  template_id text not null default 'basic', -- 'basic', 'event', 'sale', 'notice' ë“±
  form_data jsonb not null default '{}'::jsonb, -- Original form data
  
  -- Rendering Result
  html_url text, -- URL to HTML file in Storage
  html_content text, -- HTML content (for backward compatibility/backup)
  
  user_id uuid references public.users(uuid) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Indices for Flyers
create index if not exists flyers_template_id_idx on public.flyers(template_id);
create index if not exists flyers_form_data_idx on public.flyers using gin(form_data);
create index if not exists flyers_user_id_idx on public.flyers(user_id);

-- Enable RLS on flyers
alter table public.flyers enable row level security;

-- Policies for flyers
create policy "Flyers are viewable by everyone."
  on public.flyers for select
  using ( true );

create policy "Users can insert their own flyers."
  on public.flyers for insert
  with check ( auth.uid() = user_id );

create policy "Users can update own flyers."
  on public.flyers for update
  using ( auth.uid() = user_id );

create policy "Users can delete own flyers."
  on public.flyers for delete
  using ( auth.uid() = user_id );

-- 3. Storage Bucket Setup
insert into storage.buckets (id, name, public)
values ('flyers', 'flyers', true)
on conflict (id) do update set public = true;

-- Storage Policies
create policy "Authenticated users can upload flyer images"
on storage.objects for insert
to authenticated
with check ( bucket_id = 'flyers' );

create policy "Anyone can view flyer images"
on storage.objects for select
using ( bucket_id = 'flyers' );

create policy "Users can delete own flyer images"
on storage.objects for delete
to authenticated
using (
  bucket_id = 'flyers' AND
  owner = auth.uid()
);

-- 4. Functions & Triggers for User Sync

-- Function: Handle New User (INSERT)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.users (uuid, email, full_name, avatar_url)
  values (
    new.id,
    new.email,
    coalesce(
      new.raw_user_meta_data->>'full_name',
      new.raw_user_meta_data->>'name',
      ''
    ),
    new.raw_user_meta_data->>'avatar_url'
  )
  on conflict (uuid) do update
  set
    email = excluded.email,
    full_name = excluded.full_name,
    avatar_url = excluded.avatar_url,
    updated_at = now();
  return new;
end;
$$ language plpgsql security definer;

-- Function: Handle User Update (UPDATE)
create or replace function public.handle_user_update()
returns trigger as $$
begin
  update public.users
  set
    email = new.email,
    full_name = coalesce(
      new.raw_user_meta_data->>'full_name',
      new.raw_user_meta_data->>'name',
      full_name
    ),
    avatar_url = coalesce(
      new.raw_user_meta_data->>'avatar_url',
      avatar_url
    ),
    updated_at = now()
  where uuid = new.id;
  return new;
end;
$$ language plpgsql security definer;

-- Function: Handle User Delete (DELETE)
create or replace function public.handle_user_delete()
returns trigger as $$
begin
  delete from public.users where uuid = old.id;
  return old;
end;
$$ language plpgsql security definer;

-- Triggers
-- INSERT Trigger
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- UPDATE Trigger
drop trigger if exists on_auth_user_updated on auth.users;
create trigger on_auth_user_updated
  after update on auth.users
  for each row
  when (
    old.email is distinct from new.email OR
    old.raw_user_meta_data is distinct from new.raw_user_meta_data
  )
  execute procedure public.handle_user_update();

-- DELETE Trigger
drop trigger if exists on_auth_user_deleted on auth.users;
create trigger on_auth_user_deleted
  after delete on auth.users
  for each row execute procedure public.handle_user_delete();

-- 5. Data Migration (Sync existing users)
insert into public.users (uuid, email, full_name, avatar_url, created_at)
select
  id,
  email,
  coalesce(
    raw_user_meta_data->>'full_name',
    raw_user_meta_data->>'name',
    ''
  ) as full_name,
  raw_user_meta_data->>'avatar_url',
  created_at
from auth.users
on conflict (uuid) do update
set
  email = excluded.email,
  full_name = excluded.full_name,
  avatar_url = excluded.avatar_url;
